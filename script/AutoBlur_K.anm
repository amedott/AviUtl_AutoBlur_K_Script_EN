--track0:sAngle,0,720,180
--track1:sPhase,-360,360,-90
--check0:Display Original,0
--dialog:Consider Script/chk,_1=0;Enable Dir Blur/chk,_2=1;Enable Rad Blur/chk,_3=1;Enable Rot Blur/chk,_4=0;└Relative Path,_5=true;└Dll Path,_6="..\\";└Param,_7={1, 0, 1, 1};Keep Size,_8=false;Length,_9=0.95;

--サイズが0ならここで終わり
local w0, h0 = obj.getpixel()
if (w0 * h0 == 0) then
    return
end

--パラメータ
local shutter_angle = obj.track0
local shutter_phase = obj.track1
local chk_display_original = obj.check0
local chk_consider_script = _1 == 1 _1 = nil
local chk_directional_blur = _2 == 1 _2 = nil
local chk_radial_blur = _3 == 1 _3 = nil
local chk_rot_blur = _4 == 1 _4 = nil
local chk_relative_path = _5 _5 = nil
local dll_path = _6 _6 = nil
local rot_blur_param = _7 _7 = nil
local rot_blur_type = rot_blur_param[1]
local reduce_angle_resolution = rot_blur_param[2]
local quality_mode_display = rot_blur_param[3] == 1
local quality_mode_output = rot_blur_param[4] == 1
local keep_size = _8 _8 = nil
local keep_size_num = keep_size and 1 or 0
local length = _9 _9 = nil

--定数
local d_z = 1 * 1024 / (1024 + obj.getvalue("z") + obj.oz)
local amount_r = 0.02 * length * 100 / (obj.getvalue("zoom") * obj.zoom * d_z)
local amount_s = 0.035 * length * 100 / (obj.getvalue("zoom") * obj.zoom * d_z)
local amount_z = 0.00045 * length * 100 / (obj.getvalue("zoom") * obj.zoom * d_z)
local amount_theta = 0.05 * length
local dt = 1 / obj.framerate
local id = obj.index

--グローバル空間に配列を用意する
if (chk_consider_script and (_ABK_P == nil)) then
    _ABK_P = {}
end
--もし配列の中身がnilなら値を格納する
if (chk_consider_script and ((_ABK_P[id] == nil) or (obj.frame == 0))) then
    _ABK_P[id] = {
        ox = obj.ox,
        oy = obj.oy,
        oz = obj.oz,
        zoom = obj.zoom,
        rz = obj.rz,
        time = obj.time
        }
end
--警告文でも流しとく
if (chk_consider_script and id == 0 and (obj.time - _ABK_P[id].time) < 0) then
    print("[AutoBlur_K.anm] シークバーが右から左に動いています。正常な結果を得られない可能性があります。")
end

if (chk_consider_script) then
    dt = obj.time - _ABK_P[id].time
end
--負の時間（スタート時）およびdt == 0は動作しない
local t0 = obj.time - dt
if (t0 > 0 and dt ~= 0) then
    --z軸まわりに関する回転方向の速度ベクトルv_thetaと相対回転量orzの計算
    local d_theta = chk_consider_script and obj.rz - _ABK_P[id].rz or obj.getvalue("rz") - obj.getvalue("rz", t0)
    local v_theta = d_theta / dt
    local orz = chk_rot_blur and d_theta * shutter_angle * (shutter_phase + 90) / 64800 or 0
    local rz_pre = math.rad(obj.rz)

    --スケールの変更やz方向への動作によって生じる速度ベクトルvsとvzおよび相対移動量ozと相対拡大量osの計算
    local ds = chk_consider_script and obj.getvalue("zoom") * obj.zoom - obj.getvalue("zoom", t0) * _ABK_P[id].zoom or obj.getvalue("zoom") - obj.getvalue("zoom", t0)
    local dz = obj.getvalue("z") - obj.getvalue("z", t0)

    if (chk_consider_script) then
        dz = dz + obj.oz - _ABK_P[id].oz
    end

    local vs = ds / dt
    local vz = dz / dt
    local os = 1
    local oz = 0
    if (chk_radial_blur) then
        if (vs > 0) then
            os = ds * shutter_angle * shutter_phase / (64800 * obj.zoom * obj.getvalue("zoom")) + 1
        else
            os = ds * shutter_angle * (shutter_phase + 180) / (64800 * obj.zoom * obj.getvalue("zoom")) + 1
        end
        if (vz < 0) then
            oz = -dz * shutter_angle / 360
        end
        oz = oz + dz * shutter_angle * (shutter_phase + 180) / 64800
    end

    --xy平面でのオブジェクトの速度ベクトルvrと相対移動量ox, oyそして中心座標cx, cyの計算
    local dx = obj.getvalue("x") - obj.getvalue("x", t0)
    local dy = obj.getvalue("y") - obj.getvalue("y", t0)

    if (chk_consider_script) then
        dx = dx + obj.ox - _ABK_P[id].ox
        dy = dy + obj.oy - _ABK_P[id].oy
    end

    local dr = math.sqrt(dx * dx + dy * dy)
    local vr = dr / dt
    local ox = chk_directional_blur and dx * shutter_angle * (shutter_phase + 90) / 64800 or 0
    local oy = chk_directional_blur and dy * shutter_angle * (shutter_phase + 90) / 64800 or 0
    local cx = ox * math.cos(rz_pre) + oy * math.sin(rz_pre)
    local cy = -ox * math.sin(rz_pre) + oy * math.cos(rz_pre)
    cx = cx * 100  / (obj.getvalue("zoom") * obj.zoom * d_z)
    cy = cy * 100  / (obj.getvalue("zoom") * obj.zoom * d_z)

    if (chk_consider_script) then
        _ABK_P[id] = {
            ox = obj.ox,
            oy = obj.oy,
            oz = obj.oz,
            zoom = obj.zoom,
            rz = obj.rz,
            time = obj.time
            }
    end

    --オリジナルを表示するために、キャッシュを取る
    if (chk_display_original) then
        obj.copybuffer("cache:pre", "obj")
    end

    --回転ブラー
    if (chk_rot_blur) then
        --ブラーがカットされないように領域を拡張する
        local a, b = w0 / 2 + math.abs(obj.cx), h0 / 2 + math.abs(obj.cy)
        local r = math.sqrt(a * a + b * b)
        if not keep_size then
            local add_x, add_y = math.ceil(r - w0 / 2 + 1), math.ceil(r - h0 / 2 + 1)
            obj.effect("領域拡張", "上", add_y, "下", add_y, "右", add_x, "左", add_x)
        end
        local data, w, h = obj.getpixeldata()
        --dllはscriptフォルダ直下も調べる
        package.cpath = package.cpath..";"..obj.getinfo("script_path"):gsub("[^\\]+\\$", "?.dll")
        --dll pathを追加
        if (chk_relative_path) then
            package.cpath=package.cpath..";"..obj.getinfo("script_path")..dll_path
        else
            package.cpath=package.cpath..";"..dll_path
        end
    
        local chk, T_RotBlur_Module = pcall(require, "T_RotBlur_Module")
        if (chk) then
            local is_quality_mode = (not obj.getinfo("saving") and quality_mode_display) or (obj.getinfo("saving") and quality_mode_output)
            local rot_blur = is_quality_mode and T_RotBlur_Module.RotBlur_S or T_RotBlur_Module.RotBlur_L
            rot_blur(data, w, h, amount_theta * math.abs(v_theta) * shutter_angle / 360, obj.cx, obj.cy, 0, reduce_angle_resolution)
            obj.putpixeldata(data)
            --位置調整
            obj.rz = obj.rz + orz
        else
            --見つからなかった場合、コンソールにメッセージを流して回転ブラーのみ実行しない。
            print("[AutoBlur_K.anm] T_RotBlur_Module.dllが見つかりません。回転ブラーのみoffにします。")
        end
    end

    --放射ブラー
    local dcx_pre, dcy_pre, zoom_pre = obj.cx, obj.cy, obj.zoom
    if (chk_radial_blur) then
        --スケールおよびz方向の移動については放射ブラーでモーションブラーを再現する
        obj.effect("放射ブラー", "範囲", (amount_s  * math.abs(vs) + amount_z * math.abs(vz)) * shutter_angle / 360, "X", obj.cx, "Y", obj.cy, "サイズ固定", keep_size_num)
        --位置調整
        obj.zoom = obj.zoom * math.max(os, 0)
        obj.cz = obj.cz - oz
    end
    --放射ブラーによって変わった中心座標量を計算
    local dcx_tmp, dcy_tmp = (obj.cx - dcx_pre) * obj.getvalue("zoom") * zoom_pre * d_z / 100, (obj.cy - dcy_pre) * obj.getvalue("zoom") * zoom_pre * d_z / 100
    local dcx, dcy = dcx_tmp * math.cos(rz_pre) - dcy_tmp * math.sin(rz_pre), dcx_tmp * math.sin(rz_pre) + dcy_tmp * math.cos(rz_pre)

    --方向ブラー
    if (chk_directional_blur) then
        --xy平面での移動は方向ブラーでモーションブラーを再現
        obj.effect("方向ブラー", "範囲", amount_r * math.abs(vr) * shutter_angle / 360, "角度", 90 + math.deg(math.atan2(dy, dx)) - obj.rz, "サイズ固定", keep_size_num)
        --位置調整
        obj.cx = obj.cx - cx
        obj.cy = obj.cy - cy
    end

    --オリジナルをobj.draw()でフレームバッファに表示する。オリジナルはこのスクリプト以降のエフェクトの影響を受けないはず
    if (chk_display_original) then
        --このスクリプト以降のエフェクトはブラーにかける
        obj.effect()
        obj.draw()
        obj.copybuffer("obj", "cache:pre")
        obj.draw(-ox + dcx, -oy + dcy, -oz, 1 / math.max(os, 0.00000001), 1, 0, 0, -orz)
    end
else
    if (chk_consider_script) then
        _ABK_P[id] = {
            ox = obj.ox,
            oy = obj.oy,
            oz = obj.oz,
            zoom = obj.zoom,
            rz = obj.rz,
            time = obj.time
            }
    end
end

if (obj.frame == obj.totalframe) then
    _ABK_P = nil
end
